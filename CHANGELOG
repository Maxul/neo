
2017/1/11
1. 简化了获取客户机主存的实现。
    qemu_ram_alloc_from_ptr -> pc_memory_init -> pc_init_pci -> HOST_V

exec.c: host_v --> gpa
    if (!host_v)
        host_v = (ram_addr_t)(new_block->host);
        
2. 修补cal_num的实现问题。对strrchr返回值进行检查，避免空指针解引用。
    使用ftok来替代。
    
用VNC代替现有的agent扫描窗口方式。即缩小信息传输量。让更多剪切绘制工作放到server端来做。(X)
	经过验证，VNC的视频延迟大于当前实现方式。

2017/1/12
3. -hdb 参数作为ipc共享内存key和信号量key。只使用私有镜像作为ftok参数。
如果没有-hdb参数，VMOS将不运行。

2017/1/18
4. client-linux驱动实现：不再依赖/dev/mem/设备，使用新的驱动来满足用户态程序直接修改内核内存的需求。
	理由：高版本的内核对/dev/mem的限制导致现有工作无法往高平台移植。

2017/1/18
5. 重新构建ubuntu镜像。

2017/1/21
6. 代码整体阅读和流程简化。完整注释说明。

2017/1/22
7. 修复32位地址和64地址不兼容问题，统一使用uint64_t类型。

8. 修复Window和int转换问题。

2017/1/25
9. 修改前后端实现，对代码的风格和命名进行“重构”。测试新版本正常运行。

2017/1/27
10. 保证event线程和draw线程先后退出顺序。画图线程创建事件接收线程，保证后者退出后前者退出。

2017/1/28
11. 使用共享内存作为qemu给guest os分配的内存。

12. 共享内存只要5MB就够了，4MB内存用作图像传输，1MB用作事件以及命令传输。

2017/1/29
13. 前端关闭后断开再次通信时，可以继续连接运行。
    去除第一次创建线程的判断。
    删除first_image的所有操作。前端根据id号来判断是否需要插入。

2017/2/1
14. 共享内存VMI 修改交互地址：

15. 用UTF8替换原有的传输完整TextProperty的方式。
    改回来，标题栏始终乱码，bug太多。

16. 使用低1MB完成event传输。

2017/2/2
17. 修复ipc资源未释放问题。

18. 删除后端关于父窗口的线程实现，简化多余线程。
    no get_active_win thread!

19. 使用结构体完成事件序列化。
    memcpy(gpa + 200, shm_addr + IMAGE_SIZE + 20, sizeof(Item));

2017/2/3
20. 完成命令行交互方式：可以在外启动一个内部窗口。均使用线程来实现，可以使用中断来减少轮询。    
    命令行交互地址：低1MB的0xff位置。标识位：0xff，长度，之后为命令。
    
21. 使用完整结构体来传输窗口数据。更新地址分配，尽量紧凑和有逻辑，全部为uint64_t类型。
    效率有所下降，尽量避免在用户态组装数据，而是将数据直接塞到内核可以加速。
    VMI用时：real: 48.874 user: 14.364
    序列化组装视频用时：real: 37 user: 12
    直接填入内核用时：real: 37.119 user: 11.932(有待提高)
    重新启动整台机器后速度提高：可见共享内存的页面利用效率不高。real: 30.363 user: 8.684
    原始用时:real: 30.204s user: 14.700s

2017/2/4
22. 修改后端，保证了指定窗口的关闭。

23. 当内部检索不到id时，通知外部关闭它们。保证重新连接时两端的数据一致性。

24. 修复当点击窗口边框时，而非只是窗体时，激活窗口。

25. 内核空间地址标志位置：ram + 0x10。类型uint64_t。
close_notify 位置 不经过共享内存，内外直接通信：
    0xfa: flag 0xfb: winid
event事件：
    0xff: flag 0x100: event structure

2017/2/5
26. 完全VMI！！！

27. 完成前端的压力测试。

29. 解决内外使用序列化数据后的对齐问题。所有数据使用int64_t对齐。

30. 修改了depth的位置：*(int *)(mem + 3 + sizeof(int) * 11)

